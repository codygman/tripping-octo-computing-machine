module Data.Enum where
import Data.Enum ()
import Data.Maybe ()
import Data.Maybe.Unsafe ()
import Data.Unfoldable ()
import Data.Char ()
import Prelude ()
import Prim ()
import Prelude ()
import Data.Maybe ()
import Data.Either ()
import Data.Tuple ()
import Data.Char ()
import Data.Maybe.Unsafe ()
import Data.Unfoldable ()
--  | Type class for enumerations. This should not be considered a part of a
--  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
--  | ordered sum types with statically-determined cardinality and the ability 
--  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
--  |
--  | Laws:
--  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
--  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
--  |   
--  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
--  |   
--  |   for all a > firstEnum: pred a >>= succ == Just a
--  |   for all a < lastEnum:  succ a >>= pred == Just a
--  |   
--  |   pred >=> succ >=> pred = pred
--  |   succ >=> pred >=> succ = succ
--  |   
--  |   toEnum (fromEnum a) = Just a
--  |   
--  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
--  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
--  | Type class for enumerations. This should not be considered a part of a
--  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
--  | ordered sum types with statically-determined cardinality and the ability 
--  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
--  |
--  | Laws:
--  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
--  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
--  |   
--  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
--  |   
--  |   for all a > firstEnum: pred a >>= succ == Just a
--  |   for all a < lastEnum:  succ a >>= pred == Just a
--  |   
--  |   pred >=> succ >=> pred = pred
--  |   succ >=> pred >=> succ = succ
--  |   
--  |   toEnum (fromEnum a) = Just a
--  |   
--  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
--  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
--  starting value/state.
--  | Instances
--  Until we get Int, floor and div in the prelude
--  | Type class for enumerations. This should not be considered a part of a
--  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
--  | ordered sum types with statically-determined cardinality and the ability 
--  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
--  |
--  | Laws:
--  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
--  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
--  |   
--  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
--  |   
--  |   for all a > firstEnum: pred a >>= succ == Just a
--  |   for all a < lastEnum:  succ a >>= pred == Just a
--  |   
--  |   pred >=> succ >=> pred = pred
--  |   succ >=> pred >=> succ = succ
--  |   
--  |   toEnum (fromEnum a) = Just a
--  |   
--  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
--  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
--  | Type class for enumerations. This should not be considered a part of a
--  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
--  | ordered sum types with statically-determined cardinality and the ability 
--  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
--  |
--  | Laws:
--  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
--  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
--  |   
--  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
--  |   
--  |   for all a > firstEnum: pred a >>= succ == Just a
--  |   for all a < lastEnum:  succ a >>= pred == Just a
--  |   
--  |   pred >=> succ >=> pred = pred
--  |   succ >=> pred >=> succ = succ
--  |   
--  |   toEnum (fromEnum a) = Just a
--  |   
--  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
--  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
--  | Type class for enumerations. This should not be considered a part of a
--  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
--  | ordered sum types with statically-determined cardinality and the ability 
--  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
--  |
--  | Laws:
--  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
--  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
--  |   
--  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
--  |   
--  |   for all a > firstEnum: pred a >>= succ == Just a
--  |   for all a < lastEnum:  succ a >>= pred == Just a
--  |   
--  |   pred >=> succ >=> pred = pred
--  |   succ >=> pred >=> succ = succ
--  |   
--  |   toEnum (fromEnum a) = Just a
--  |   
--  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
--  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
--  | Type class for enumerations. This should not be considered a part of a
--  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
--  | ordered sum types with statically-determined cardinality and the ability 
--  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
--  |
--  | Laws:
--  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
--  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
--  |   
--  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
--  |   
--  |   for all a > firstEnum: pred a >>= succ == Just a
--  |   for all a < lastEnum:  succ a >>= pred == Just a
--  |   
--  |   pred >=> succ >=> pred = pred
--  |   succ >=> pred >=> succ = succ
--  |   
--  |   toEnum (fromEnum a) = Just a
--  |   
--  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
--  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
--  Property: forall e in intStepFromTo step a b: a <= e <= b
--  intStepFromTo :: Int -> Int -> Int -> List Int
--  Property: forall e in intFromTo a b: a <= e <= b
--  intFromTo :: Int -> Int -> List Int
--  | Type class for enumerations. This should not be considered a part of a
--  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
--  | ordered sum types with statically-determined cardinality and the ability 
--  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
--  |
--  | Laws:
--  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
--  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
--  |   
--  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
--  |   
--  |   for all a > firstEnum: pred a >>= succ == Just a
--  |   for all a < lastEnum:  succ a >>= pred == Just a
--  |   
--  |   pred >=> succ >=> pred = pred
--  |   succ >=> pred >=> succ = succ
--  |   
--  |   toEnum (fromEnum a) = Just a
--  |   
--  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
--  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
--  | Type class for enumerations. This should not be considered a part of a
--  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
--  | ordered sum types with statically-determined cardinality and the ability 
--  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
--  |
--  | Laws:
--  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
--  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
--  |   
--  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
--  |   
--  |   for all a > firstEnum: pred a >>= succ == Just a
--  |   for all a < lastEnum:  succ a >>= pred == Just a
--  |   
--  |   pred >=> succ >=> pred = pred
--  |   succ >=> pred >=> succ = succ
--  |   
--  |   toEnum (fromEnum a) = Just a
--  |   
--  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
--  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
--  Property: fromEnum a = a', fromEnum b = b' => forall e', a' <= e' <= b': Exists e: toEnum e' = Just e
--  Following from the propery of intFromTo, We are sure all elements in intFromTo (fromEnum a) (fromEnum b) are Justs.
--  [a,b..c]
--  Correctness for using fromJust is the same as for enumFromTo.
--  All of these are as a workaround for ScopedTypeVariables. (not yet supported in Purescript)
--  | Runs in O(n) where n is (fromEnum a)
--  | defaultToEnum succ firstEnum = toEnum
--  | defaultSucc toEnum fromEnum = succ
--  | defaultPred toEnum fromEnum = pred
--  | Runs in O(n) where n is (fromEnum a)
--  | defaultFromEnum pred = fromEnum
--  To avoid a compiler bug - can't pass self-class functions, workaround: need to make a concrete function.
--  starting value/state.
--  | Instances
--  | Type class for enumerations. This should not be considered a part of a
--  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
--  | ordered sum types with statically-determined cardinality and the ability 
--  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
--  |
--  | Laws:
--  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
--  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
--  |   
--  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
--  |   
--  |   for all a > firstEnum: pred a >>= succ == Just a
--  |   for all a < lastEnum:  succ a >>= pred == Just a
--  |   
--  |   pred >=> succ >=> pred = pred
--  |   succ >=> pred >=> succ = succ
--  |   
--  |   toEnum (fromEnum a) = Just a
--  |   
--  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
--  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
newtype Cardinality (a :: *) = Cardinality Prim.Number
class (Prelude.Ord a) <= Enum a where
  cardinality :: Data.Enum.Cardinality a
  firstEnum :: a
  lastEnum :: a
  succ :: a -> Data.Maybe.Maybe a
  pred :: a -> Data.Maybe.Maybe a
  toEnum :: Prim.Number -> Data.Maybe.Maybe a
  fromEnum :: a -> Prim.Number
foreign import enumFromThenTo :: forall a. (Data.Enum.Enum a) => a -> a -> a -> [a]
foreign import enumFromTo :: forall a. (Data.Enum.Enum a) => a -> a -> [a]
foreign import intStepFromTo :: Prim.Number -> Prim.Number -> Prim.Number -> [Prim.Number]
foreign import intFromTo :: Prim.Number -> Prim.Number -> [Prim.Number]
foreign import defaultFromEnum :: forall a. (a -> Data.Maybe.Maybe a) -> a -> Prim.Number
foreign import defaultToEnum :: forall a. (a -> Data.Maybe.Maybe a) -> a -> Prim.Number -> Data.Maybe.Maybe a
foreign import defaultPred :: forall a. (Prim.Number -> Data.Maybe.Maybe a) -> (a -> Prim.Number) -> a -> Data.Maybe.Maybe a
foreign import defaultSucc :: forall a. (Prim.Number -> Data.Maybe.Maybe a) -> (a -> Prim.Number) -> a -> Data.Maybe.Maybe a
foreign import runCardinality :: forall a. Data.Enum.Cardinality a -> Prim.Number
foreign import instance enumChar :: Data.Enum.Enum Data.Char.Char
foreign import instance enumMaybe :: (Data.Enum.Enum a) => Data.Enum.Enum (Data.Maybe.Maybe a)
foreign import instance enumBoolean :: Data.Enum.Enum Prim.Boolean
foreign import instance enumTuple :: (Data.Enum.Enum a, Data.Enum.Enum b) => Data.Enum.Enum (Data.Tuple.Tuple a b)
foreign import instance enumEither :: (Data.Enum.Enum a, Data.Enum.Enum b) => Data.Enum.Enum (Data.Either.Either a b)
