"use strict";
var Data_Maybe = require("Data.Maybe");
var Data_Maybe_Unsafe = require("Data.Maybe.Unsafe");
var Data_Unfoldable = require("Data.Unfoldable");
var Data_Char = require("Data.Char");
var Prelude = require("Prelude");
var Data_Either = require("Data.Either");
var Data_Tuple = require("Data.Tuple");
var Data_Array = require("Data.Array");
function floor(n){ return Math.floor(n); };
var Cardinality = function (x) {
    return x;
};

/**
 *  | Type class for enumerations. This should not be considered a part of a
 *  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
 *  | ordered sum types with statically-determined cardinality and the ability 
 *  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
 *  |
 *  | Laws:
 *  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
 *  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
 *  |   
 *  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
 *  |   
 *  |   for all a > firstEnum: pred a >>= succ == Just a
 *  |   for all a < lastEnum:  succ a >>= pred == Just a
 *  |   
 *  |   pred >=> succ >=> pred = pred
 *  |   succ >=> pred >=> succ = succ
 *  |   
 *  |   toEnum (fromEnum a) = Just a
 *  |   
 *  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
 *  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
 */
var Enum = function (__superclass_Prelude$dotOrd_0, cardinality, firstEnum, fromEnum, lastEnum, pred, succ, toEnum) {
    this["__superclass_Prelude.Ord_0"] = __superclass_Prelude$dotOrd_0;
    this.cardinality = cardinality;
    this.firstEnum = firstEnum;
    this.fromEnum = fromEnum;
    this.lastEnum = lastEnum;
    this.pred = pred;
    this.succ = succ;
    this.toEnum = toEnum;
};

/**
 *  | Type class for enumerations. This should not be considered a part of a
 *  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
 *  | ordered sum types with statically-determined cardinality and the ability 
 *  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
 *  |
 *  | Laws:
 *  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
 *  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
 *  |   
 *  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
 *  |   
 *  |   for all a > firstEnum: pred a >>= succ == Just a
 *  |   for all a < lastEnum:  succ a >>= pred == Just a
 *  |   
 *  |   pred >=> succ >=> pred = pred
 *  |   succ >=> pred >=> succ = succ
 *  |   
 *  |   toEnum (fromEnum a) = Just a
 *  |   
 *  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
 *  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
 */
var toEnum = function (dict) {
    return dict.toEnum;
};

/**
 *  | Type class for enumerations. This should not be considered a part of a
 *  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
 *  | ordered sum types with statically-determined cardinality and the ability 
 *  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
 *  |
 *  | Laws:
 *  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
 *  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
 *  |   
 *  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
 *  |   
 *  |   for all a > firstEnum: pred a >>= succ == Just a
 *  |   for all a < lastEnum:  succ a >>= pred == Just a
 *  |   
 *  |   pred >=> succ >=> pred = pred
 *  |   succ >=> pred >=> succ = succ
 *  |   
 *  |   toEnum (fromEnum a) = Just a
 *  |   
 *  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
 *  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
 */
var succ = function (dict) {
    return dict.succ;
};
var runCardinality = function (_3) {
    return _3;
};
var tupleCardinality = function (__dict_Enum_0) {
    return function (__dict_Enum_1) {
        return function (l) {
            return function (r) {
                return Cardinality(runCardinality(l) * runCardinality(r));
            };
        };
    };
};

/**
 *  | Type class for enumerations. This should not be considered a part of a
 *  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
 *  | ordered sum types with statically-determined cardinality and the ability 
 *  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
 *  |
 *  | Laws:
 *  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
 *  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
 *  |   
 *  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
 *  |   
 *  |   for all a > firstEnum: pred a >>= succ == Just a
 *  |   for all a < lastEnum:  succ a >>= pred == Just a
 *  |   
 *  |   pred >=> succ >=> pred = pred
 *  |   succ >=> pred >=> succ = succ
 *  |   
 *  |   toEnum (fromEnum a) = Just a
 *  |   
 *  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
 *  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
 */
var pred = function (dict) {
    return dict.pred;
};
var maybeCardinality = function (__dict_Enum_2) {
    return function (c) {
        return Cardinality(1 + runCardinality(c));
    };
};
var maybeToEnum = function (__dict_Enum_3) {
    return function (_8) {
        return function (_9) {
            if (_9 <= runCardinality(maybeCardinality(__dict_Enum_3)(_8))) {
                var _33 = _9 === 0;
                if (_33) {
                    return Data_Maybe.Just.create(Data_Maybe.Nothing.value);
                };
                if (!_33) {
                    return Data_Maybe.Just.create(toEnum(__dict_Enum_3)(_9 - 1));
                };
                throw new Error("Failed pattern match");
            };
            return Data_Maybe.Nothing.value;
        };
    };
};

/**
 *  | Type class for enumerations. This should not be considered a part of a
 *  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
 *  | ordered sum types with statically-determined cardinality and the ability 
 *  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
 *  |
 *  | Laws:
 *  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
 *  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
 *  |   
 *  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
 *  |   
 *  |   for all a > firstEnum: pred a >>= succ == Just a
 *  |   for all a < lastEnum:  succ a >>= pred == Just a
 *  |   
 *  |   pred >=> succ >=> pred = pred
 *  |   succ >=> pred >=> succ = succ
 *  |   
 *  |   toEnum (fromEnum a) = Just a
 *  |   
 *  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
 *  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
 */
var lastEnum = function (dict) {
    return dict.lastEnum;
};

/**
 *  Property: forall e in intStepFromTo step a b: a <= e <= b
 *  intStepFromTo :: Int -> Int -> Int -> List Int
 */
var intStepFromTo = function (step) {
    return function (from) {
        return function (to) {
            return Data_Unfoldable.unfoldr(Data_Unfoldable.unfoldableArray)(function (e) {
                var _34 = e <= to;
                if (_34) {
                    return Data_Maybe.Just.create(new Data_Tuple.Tuple(e, e + step));
                };
                if (!_34) {
                    return Data_Maybe.Nothing.value;
                };
                throw new Error("Failed pattern match");
            })(from);
        };
    };
};

/**
 *  Property: forall e in intFromTo a b: a <= e <= b
 *  intFromTo :: Int -> Int -> List Int
 */
var intFromTo = intStepFromTo(1);

/**
 *  | Type class for enumerations. This should not be considered a part of a
 *  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
 *  | ordered sum types with statically-determined cardinality and the ability 
 *  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
 *  |
 *  | Laws:
 *  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
 *  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
 *  |   
 *  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
 *  |   
 *  |   for all a > firstEnum: pred a >>= succ == Just a
 *  |   for all a < lastEnum:  succ a >>= pred == Just a
 *  |   
 *  |   pred >=> succ >=> pred = pred
 *  |   succ >=> pred >=> succ = succ
 *  |   
 *  |   toEnum (fromEnum a) = Just a
 *  |   
 *  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
 *  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
 */
var fromEnum = function (dict) {
    return dict.fromEnum;
};
var tupleFromEnum = function (__dict_Enum_4) {
    return function (__dict_Enum_5) {
        return function (_12) {
            return function (_13) {
                return fromEnum(__dict_Enum_4)(_13.value0) * runCardinality(_12) + fromEnum(__dict_Enum_5)(_13.value1);
            };
        };
    };
};

/**
 *  | Type class for enumerations. This should not be considered a part of a
 *  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
 *  | ordered sum types with statically-determined cardinality and the ability 
 *  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
 *  |
 *  | Laws:
 *  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
 *  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
 *  |   
 *  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
 *  |   
 *  |   for all a > firstEnum: pred a >>= succ == Just a
 *  |   for all a < lastEnum:  succ a >>= pred == Just a
 *  |   
 *  |   pred >=> succ >=> pred = pred
 *  |   succ >=> pred >=> succ = succ
 *  |   
 *  |   toEnum (fromEnum a) = Just a
 *  |   
 *  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
 *  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
 */
var firstEnum = function (dict) {
    return dict.firstEnum;
};

/**
 *  Property: fromEnum a = a', fromEnum b = b' => forall e', a' <= e' <= b': Exists e: toEnum e' = Just e
 *  Following from the propery of intFromTo, We are sure all elements in intFromTo (fromEnum a) (fromEnum b) are Justs.
 */
var enumFromTo = function (__dict_Enum_6) {
    return function (a) {
        return function (b) {
            var b$prime = fromEnum(__dict_Enum_6)(b);
            var a$prime = fromEnum(__dict_Enum_6)(a);
            return Prelude["<$>"](Data_Array.functorArray)(Prelude[">>>"](Prelude.semigroupoidArr)(toEnum(__dict_Enum_6))(Data_Maybe_Unsafe.fromJust))(intFromTo(a$prime)(b$prime));
        };
    };
};

/**
 *  [a,b..c]
 *  Correctness for using fromJust is the same as for enumFromTo.
 */
var enumFromThenTo = function (__dict_Enum_7) {
    return function (a) {
        return function (b) {
            return function (c) {
                var c$prime = fromEnum(__dict_Enum_7)(c);
                var b$prime = fromEnum(__dict_Enum_7)(b);
                var a$prime = fromEnum(__dict_Enum_7)(a);
                return Prelude["<$>"](Data_Array.functorArray)(Prelude[">>>"](Prelude.semigroupoidArr)(toEnum(__dict_Enum_7))(Data_Maybe_Unsafe.fromJust))(intStepFromTo(b$prime - a$prime)(a$prime)(c$prime));
            };
        };
    };
};
var eitherFromEnum = function (__dict_Enum_8) {
    return function (__dict_Enum_9) {
        return function (_14) {
            return function (_15) {
                if (_15 instanceof Data_Either.Left) {
                    return fromEnum(__dict_Enum_8)(_15.value0);
                };
                if (_15 instanceof Data_Either.Right) {
                    return fromEnum(__dict_Enum_9)(_15.value0) + runCardinality(_14);
                };
                throw new Error("Failed pattern match");
            };
        };
    };
};
var eitherCardinality = function (__dict_Enum_10) {
    return function (__dict_Enum_11) {
        return function (l) {
            return function (r) {
                return Cardinality(runCardinality(l) + runCardinality(r));
            };
        };
    };
};
var eitherToEnum = function (__dict_Enum_12) {
    return function (__dict_Enum_13) {
        return function (carda) {
            return function (cardb) {
                return function (n) {
                    var _43 = n >= 0 && n < runCardinality(carda);
                    if (_43) {
                        return Prelude["<$>"](Data_Maybe.functorMaybe)(Data_Either.Left.create)(toEnum(__dict_Enum_12)(n));
                    };
                    if (!_43) {
                        var _44 = n >= runCardinality(carda) && n < runCardinality(eitherCardinality(__dict_Enum_12)(__dict_Enum_13)(carda)(cardb));
                        if (_44) {
                            return Prelude["<$>"](Data_Maybe.functorMaybe)(Data_Either.Right.create)(toEnum(__dict_Enum_13)(n - runCardinality(carda)));
                        };
                        if (!_44) {
                            return Data_Maybe.Nothing.value;
                        };
                        throw new Error("Failed pattern match");
                    };
                    throw new Error("Failed pattern match");
                };
            };
        };
    };
};
var div = function (a) {
    return function (b) {
        return floor(a / b);
    };
};

/**
 *  All of these are as a workaround for ScopedTypeVariables. (not yet supported in Purescript)
 */
var tupleToEnum = function (__dict_Enum_14) {
    return function (__dict_Enum_15) {
        return function (cardb) {
            return function (n) {
                return Prelude["<*>"](Data_Maybe.applyMaybe)(Prelude["<$>"](Data_Maybe.functorMaybe)(Data_Tuple.Tuple.create)(toEnum(__dict_Enum_14)(div(n)(runCardinality(cardb)))))(toEnum(__dict_Enum_15)(n % runCardinality(cardb)));
            };
        };
    };
};

/**
 *  | Runs in O(n) where n is (fromEnum a)
 *  | defaultToEnum succ firstEnum = toEnum
 */
var defaultToEnum = function (_4) {
    return function (_5) {
        return function (_6) {
            if (_6 < 0) {
                return Data_Maybe.Nothing.value;
            };
            if (_6 === 0) {
                return new Data_Maybe.Just(_5);
            };
            return Prelude[">>="](Data_Maybe.bindMaybe)(defaultToEnum(_4)(_5)(_6 - 1))(_4);
        };
    };
};

/**
 *  | defaultSucc toEnum fromEnum = succ
 */
var defaultSucc = function (toEnum$prime) {
    return function (fromEnum$prime) {
        return function (a) {
            return toEnum$prime(fromEnum$prime(a) + 1);
        };
    };
};

/**
 *  | defaultPred toEnum fromEnum = pred
 */
var defaultPred = function (toEnum$prime) {
    return function (fromEnum$prime) {
        return function (a) {
            return toEnum$prime(fromEnum$prime(a) - 1);
        };
    };
};

/**
 *  | Runs in O(n) where n is (fromEnum a)
 *  | defaultFromEnum pred = fromEnum
 */
var defaultFromEnum = function (pred$prime) {
    return function (e) {
        return Data_Maybe.maybe(0)(function (prd) {
            return defaultFromEnum(pred$prime)(prd) + 1;
        })(pred$prime(e));
    };
};

/**
 *  To avoid a compiler bug - can't pass self-class functions, workaround: need to make a concrete function.
 */
var charToEnum = function (_7) {
    if (_7 >= 0 && _7 <= 65535) {
        return Data_Maybe.Just.create(Data_Char.fromCharCode(_7));
    };
    return Data_Maybe.Nothing.value;
};
var charFromEnum = Data_Char.toCharCode;

/**
 *  starting value/state.
 *  | Instances
 */
var enumChar = new Enum(function () {
    return Data_Char.ordChar;
}, 65535 + 1, Data_Char.fromCharCode(0), charFromEnum, Data_Char.fromCharCode(65535), defaultPred(charToEnum)(charFromEnum), defaultSucc(charToEnum)(charFromEnum), charToEnum);

/**
 *  | Type class for enumerations. This should not be considered a part of a
 *  | numeric hierarchy, ala Haskell. Rather, this is a type class for small,
 *  | ordered sum types with statically-determined cardinality and the ability 
 *  | to easily compute successor and predecessor elements. e.g. DayOfWeek, etc.
 *  |
 *  | Laws:
 *  |   succ firstEnum >>= succ >>= succ ... succ [cardinality - 1 times] == lastEnum
 *  |   pred lastEnum  >>= pred >>= pred ... pred [cardinality - 1 times] == firstEnum
 *  |   
 *  |   e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2
 *  |   
 *  |   for all a > firstEnum: pred a >>= succ == Just a
 *  |   for all a < lastEnum:  succ a >>= pred == Just a
 *  |   
 *  |   pred >=> succ >=> pred = pred
 *  |   succ >=> pred >=> succ = succ
 *  |   
 *  |   toEnum (fromEnum a) = Just a
 *  |   
 *  |   for all a > firstEnum: fromEnum <$> pred a = Just (fromEnum a - 1)
 *  |   for all a < lastEnum:  fromEnum <$> succ a = Just (fromEnum a + 1)
 */
var cardinality = function (dict) {
    return dict.cardinality;
};
var enumEither = function (__dict_Enum_16) {
    return function (__dict_Enum_17) {
        return new Enum(function () {
            return Data_Either.ordEither(__dict_Enum_16["__superclass_Prelude.Ord_0"]())(__dict_Enum_17["__superclass_Prelude.Ord_0"]());
        }, eitherCardinality(__dict_Enum_16)(__dict_Enum_17)(cardinality(__dict_Enum_16))(cardinality(__dict_Enum_17)), new Data_Either.Left(firstEnum(__dict_Enum_16)), eitherFromEnum(__dict_Enum_16)(__dict_Enum_17)(cardinality(__dict_Enum_16)), new Data_Either.Right(lastEnum(__dict_Enum_17)), function (_22) {
            if (_22 instanceof Data_Either.Left) {
                return Data_Maybe.maybe(Data_Maybe.Nothing.value)(Prelude["<<<"](Prelude.semigroupoidArr)(Data_Maybe.Just.create)(Data_Either.Left.create))(pred(__dict_Enum_16)(_22.value0));
            };
            if (_22 instanceof Data_Either.Right) {
                return Data_Maybe.maybe(Data_Maybe.Just.create(new Data_Either.Left(lastEnum(__dict_Enum_16))))(Prelude["<<<"](Prelude.semigroupoidArr)(Data_Maybe.Just.create)(Data_Either.Right.create))(pred(__dict_Enum_17)(_22.value0));
            };
            throw new Error("Failed pattern match");
        }, function (_21) {
            if (_21 instanceof Data_Either.Left) {
                return Data_Maybe.maybe(Data_Maybe.Just.create(new Data_Either.Right(firstEnum(__dict_Enum_17))))(Prelude["<<<"](Prelude.semigroupoidArr)(Data_Maybe.Just.create)(Data_Either.Left.create))(succ(__dict_Enum_16)(_21.value0));
            };
            if (_21 instanceof Data_Either.Right) {
                return Data_Maybe.maybe(Data_Maybe.Nothing.value)(Prelude["<<<"](Prelude.semigroupoidArr)(Data_Maybe.Just.create)(Data_Either.Right.create))(succ(__dict_Enum_17)(_21.value0));
            };
            throw new Error("Failed pattern match");
        }, eitherToEnum(__dict_Enum_16)(__dict_Enum_17)(cardinality(__dict_Enum_16))(cardinality(__dict_Enum_17)));
    };
};
var enumMaybe = function (__dict_Enum_18) {
    return new Enum(function () {
        return Data_Maybe.ordMaybe(__dict_Enum_18["__superclass_Prelude.Ord_0"]());
    }, maybeCardinality(__dict_Enum_18)(cardinality(__dict_Enum_18)), Data_Maybe.Nothing.value, function (_18) {
        if (_18 instanceof Data_Maybe.Nothing) {
            return 0;
        };
        if (_18 instanceof Data_Maybe.Just) {
            return fromEnum(__dict_Enum_18)(_18.value0) + 1;
        };
        throw new Error("Failed pattern match");
    }, Data_Maybe.Just.create(lastEnum(__dict_Enum_18)), function (_17) {
        if (_17 instanceof Data_Maybe.Nothing) {
            return Data_Maybe.Nothing.value;
        };
        if (_17 instanceof Data_Maybe.Just) {
            return Prelude["<$>"](Data_Maybe.functorMaybe)(Data_Maybe.Just.create)(pred(__dict_Enum_18)(_17.value0));
        };
        throw new Error("Failed pattern match");
    }, function (_16) {
        if (_16 instanceof Data_Maybe.Nothing) {
            return Data_Maybe.Just.create(firstEnum(enumMaybe(__dict_Enum_18)));
        };
        if (_16 instanceof Data_Maybe.Just) {
            return Prelude["<$>"](Data_Maybe.functorMaybe)(Data_Maybe.Just.create)(succ(__dict_Enum_18)(_16.value0));
        };
        throw new Error("Failed pattern match");
    }, maybeToEnum(__dict_Enum_18)(cardinality(__dict_Enum_18)));
};
var enumTuple = function (__dict_Enum_19) {
    return function (__dict_Enum_20) {
        return new Enum(function () {
            return Data_Tuple.ordTuple(__dict_Enum_19["__superclass_Prelude.Ord_0"]())(__dict_Enum_20["__superclass_Prelude.Ord_0"]());
        }, tupleCardinality(__dict_Enum_19)(__dict_Enum_20)(cardinality(__dict_Enum_19))(cardinality(__dict_Enum_20)), new Data_Tuple.Tuple(firstEnum(__dict_Enum_19), firstEnum(__dict_Enum_20)), tupleFromEnum(__dict_Enum_19)(__dict_Enum_20)(cardinality(__dict_Enum_20)), new Data_Tuple.Tuple(lastEnum(__dict_Enum_19), lastEnum(__dict_Enum_20)), function (_20) {
            return Data_Maybe.maybe(Prelude["<$>"](Data_Maybe.functorMaybe)(Prelude.flip(Data_Tuple.Tuple.create)(firstEnum(__dict_Enum_20)))(pred(__dict_Enum_19)(_20.value0)))(Prelude["<<<"](Prelude.semigroupoidArr)(Data_Maybe.Just.create)(Data_Tuple.Tuple.create(_20.value0)))(pred(__dict_Enum_20)(_20.value1));
        }, function (_19) {
            return Data_Maybe.maybe(Prelude["<$>"](Data_Maybe.functorMaybe)(Prelude.flip(Data_Tuple.Tuple.create)(firstEnum(__dict_Enum_20)))(succ(__dict_Enum_19)(_19.value0)))(Prelude["<<<"](Prelude.semigroupoidArr)(Data_Maybe.Just.create)(Data_Tuple.Tuple.create(_19.value0)))(succ(__dict_Enum_20)(_19.value1));
        }, tupleToEnum(__dict_Enum_19)(__dict_Enum_20)(cardinality(__dict_Enum_20)));
    };
};
var booleanSucc = function (_10) {
    if (!_10) {
        return new Data_Maybe.Just(true);
    };
    return Data_Maybe.Nothing.value;
};
var booleanPred = function (_11) {
    if (_11) {
        return new Data_Maybe.Just(false);
    };
    return Data_Maybe.Nothing.value;
};
var booleanFirstEnum = false;
var enumBoolean = new Enum(function () {
    return Prelude.ordBoolean;
}, 2, booleanFirstEnum, defaultFromEnum(booleanPred), true, booleanPred, booleanSucc, defaultToEnum(booleanSucc)(booleanFirstEnum));
module.exports = {
    Cardinality: Cardinality, 
    Enum: Enum, 
    enumFromThenTo: enumFromThenTo, 
    enumFromTo: enumFromTo, 
    intStepFromTo: intStepFromTo, 
    intFromTo: intFromTo, 
    defaultFromEnum: defaultFromEnum, 
    defaultToEnum: defaultToEnum, 
    defaultPred: defaultPred, 
    defaultSucc: defaultSucc, 
    toEnum: toEnum, 
    succ: succ, 
    runCardinality: runCardinality, 
    pred: pred, 
    lastEnum: lastEnum, 
    fromEnum: fromEnum, 
    firstEnum: firstEnum, 
    cardinality: cardinality, 
    enumChar: enumChar, 
    enumMaybe: enumMaybe, 
    enumBoolean: enumBoolean, 
    enumTuple: enumTuple, 
    enumEither: enumEither
};
